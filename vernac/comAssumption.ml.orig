(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *         Copyright INRIA, CNRS and contributors             *)
(* <O___,, * (see version control and CREDITS file for authors & dates) *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open CErrors
open Util
open Vars
open Names
open Context
open Constrintern
open Impargs
open Pretyping
open Entries

module RelDecl = Context.Rel.Declaration
(* 2| Variable/Hypothesis/Parameter/Axiom declarations *)

let context_set_of_entry = function
  | Polymorphic_entry (_,uctx) -> Univ.ContextSet.of_context uctx
  | Monomorphic_entry uctx -> uctx

(** Declares a local variable/let, possibly declaring it:
    - as a coercion (is_coe)
    - as a type class instance
    - with implicit arguments (impls)
    - with implicit status for discharge (impl)
    - virtually with named universes *)

let declare_local is_coe ~poly ~kind body typ univs imps impl name =
  let (univs, (*Univ names not supported on variables*) _names) = univs in
  let decl = match body with
    | None ->
      let () = DeclareUctx.declare_universe_context ~poly (context_set_of_entry univs) in
      Declare.SectionLocalAssum {typ; impl}
    | Some b ->
      Declare.SectionLocalDef (Declare.definition_entry ~univs ~types:typ b) in
  let () = Declare.declare_variable ~name ~kind decl in
  let () = if body = None then Declare.assumption_message name else Declare.definition_message name in
  let r = GlobRef.VarRef name in
  let () = maybe_declare_manual_implicits true r imps in
  let env = Global.env () in
  let sigma = Evd.from_env env in
  let () = if body = None then Classes.declare_instance env sigma None Goptions.OptLocal r in
  let () = if is_coe then ComCoercion.try_add_new_coercion r ~local:true in
  (r, Univ.Instance.empty)

let declare_variable is_coe ~poly ~kind typ univs imps impl name =
  declare_local is_coe ~poly ~kind:(Decls.IsAssumption kind) None typ univs imps impl name

let instance_of_univ_entry = function
  | Polymorphic_entry (_, univs) -> Univ.UContext.instance univs
  | Monomorphic_entry _ -> Univ.Instance.empty

(** Declares a global axiom/parameter, possibly declaring it:
    - as a coercion
    - as a type class instance
    - with implicit arguments
    - with inlining for functor application
    - with named universes *)

let declare_global is_coe ~poly ~local ~kind body typ (univs, pl) imps nl name =
  let do_instance = let open Decls in match kind with
  | IsAssumption Context -> body = None
    (* The typeclass behaviour of Variable and Context doesn't depend
       on section status *)
  | _ -> false
  in
  let inl = let open Declaremods in match nl with
    | NoInline -> None
    | DefaultInline -> Some (Flags.get_inline_level())
    | InlineAt i -> Some i
  in
  let decl = match body with
    | None -> Declare.ParameterEntry (None,(typ,univs),inl)
    | Some b -> Declare.DefinitionEntry (Declare.definition_entry ~univs ~types:typ b) in
  let kn = Declare.declare_constant ~name ~local ~kind decl in
  let gr = GlobRef.ConstRef kn in
  let () = maybe_declare_manual_implicits false gr imps in
  let () = DeclareUniv.declare_univ_binders gr pl in
  let () = match body with None -> Declare.assumption_message name | Some _ -> Declare.definition_message name in
  let env = Global.env () in
  let sigma = Evd.from_env env in
  let () = if do_instance then Classes.declare_instance env sigma None Goptions.OptGlobal gr in
  let local = match local with
    | Locality.ImportNeedQualified -> true
    | Locality.ImportDefaultBehavior -> false
  in
  let () = if is_coe then ComCoercion.try_add_new_coercion gr ~local in
  let inst = instance_of_univ_entry univs in
  (gr,inst)

let declare_axiom is_coe ~poly ~local ~kind typ univs imps nl name =
  declare_global is_coe ~poly ~local ~kind:(Decls.IsAssumption kind) None typ univs imps nl name

let interp_assumption ~program_mode env sigma impl_env bl c =
  let flags = { Pretyping.all_no_fail_flags with program_mode } in
  let sigma, (impls, ((env_bl, ctx), impls1)) = interp_context_evars ~program_mode ~impl_env env sigma bl in
  let sigma, (ty, impls2) = interp_type_evars_impls ~flags env_bl sigma ~impls c in
  let ty = EConstr.it_mkProd_or_LetIn ty ctx in
  sigma, ty, impls1@impls2

(* When monomorphic, the universe constraints and universe names
   are declared once for all *)
let prepare_assumptions_with_universe scope (univ_entry,_ as univs) decls =
  let add_univ_id univs CAst.{v=id} = (id,univs) in
  let add_univ univs decls =
    List.map (fun ((is_coe,ids),typ,imps) ->
      ((is_coe,List.map (add_univ_id univs) ids),typ,imps)) decls
  in
  match scope, univ_entry with
  | Locality.Discharge, Polymorphic_entry _ ->
    assert false
  | Locality.Global _, Polymorphic_entry _ ->
    add_univ univs decls
  | _, Monomorphic_entry _ ->
    let () = match scope with
    | Locality.Discharge ->
      (* declare universes separately for variables *)
      DeclareUctx.declare_universe_context ~poly:false (context_set_of_entry univ_entry);
    | Locality.Global _ -> ()
    in
    let empty_univs = Monomorphic_entry Univ.ContextSet.empty, UnivNames.empty_binders in
    match decls with
    | ((is_coe,CAst.{v=id}::ids),typ,imps) :: decls ->
      ((is_coe,(id,univs)::List.map (add_univ_id empty_univs) ids),typ,imps) ::
        add_univ empty_univs decls
    | ((_,[]),_,_) :: _ | [] -> assert false

let empty_poly_univ_entry = Polymorphic_entry ([| |], Univ.UContext.empty), UnivNames.empty_binders
let empty_mono_univ_entry = Monomorphic_entry Univ.ContextSet.empty, UnivNames.empty_binders
let empty_univ_entry poly = if poly then empty_poly_univ_entry else empty_mono_univ_entry

let clear_univs scope univ =
  match scope, univ with
  | Locality.Global _, (Polymorphic_entry _, _ as univs) -> univs
  | _, (Monomorphic_entry _, _) -> empty_univ_entry false
  | _, (Polymorphic_entry _, _) -> empty_univ_entry true

let context_subst subst (name,b,t,impl) =
  name, Option.map (Vars.substl subst) b, Vars.substl subst t, impl

<<<<<<< HEAD
let declare_context ~poly ~scope univs ctx =
  let fn i subst d =
    let (name,b,t,impl) = context_subst subst d in
    let kind = Decls.(if b = None then IsAssumption Context else IsDefinition LetContext) in
=======
let declare_context ~poly ~scope univs nl ctx =
  let fn i subst d =
    let (name,b,t,(impl,kind,is_coe,impls)) = context_subst subst d in
>>>>>>> e4d415404e... Preparing declare_context to subsume declare_assumptions.
    let univs = if i = 0 then univs else clear_univs scope univs in
    let refu = match scope with
      | Locality.Discharge -> declare_local is_coe ~poly ~kind b t univs impls impl name
      | Locality.Global local -> declare_global is_coe ~poly ~local ~kind b t univs impls nl name in
    Constr.mkRef refu :: subst
  in
  let _ : Vars.substl = List.fold_left_i fn 0 [] ctx in
  ()

let declare_assumptions ~poly ~scope ~kind univs nl decls =
  let decls = prepare_assumptions_with_universe scope univs decls in
  let _ = List.fold_left (fun subst ((is_coe,idl),typ,imps) ->
      (* NB: here univs are ignored when scope=Discharge *)
      let typ = replace_vars subst typ in
      let subst' =
        List.map (fun (id,univs) ->
            let refu = match scope with
              | Locality.Discharge ->
                declare_variable is_coe ~poly ~kind typ univs imps Glob_term.Explicit id
              | Locality.Global local ->
                declare_axiom is_coe ~local ~poly ~kind typ univs imps nl id
            in
            (id, Constr.mkRef refu))
          idl
      in
      subst'@subst)
      [] decls
  in
  ()

let error_extra_universe_decl ?loc () =
  user_err ?loc ~hdr:"many_universe_declarations"
      Pp.(strbrk "When declaring multiple assumptions in one command, " ++
          strbrk "only the first name is allowed to mention a universe binder " ++
          strbrk "(which will be shared by the whole block).")

let extract_assumption_names = function
  | ({CAst.loc;v=id}, Some _) -> error_extra_universe_decl ?loc ()
  | (id, None) -> id

let process_assumptions_udecls = function
  | (coe, ((id, udecl)::ids, c))::assums ->
    let ids = List.map extract_assumption_names ids in
    let assums = List.map (fun (coe, (idl, c)) -> (coe, (List.map extract_assumption_names idl, c))) assums in
    udecl, (coe,(id::ids,c))::assums
  | (_, ([], _))::_ | [] -> assert false

let error_polymorphic_section_variable ?loc () =
  user_err ?loc (Pp.str "Section variables cannot be polymorphic.")

let process_assumptions_no_udecls l =
  List.map (fun (coe, (ids, c)) ->
      (coe, (List.map (function
                 | ({CAst.loc}, Some _) -> error_polymorphic_section_variable ?loc ()
                 | (id, None) -> id) ids, c))) l

let do_assumptions ~program_mode ~poly ~scope ~kind nl l =
  let open Context.Named.Declaration in
  let env = Global.env () in
  let udecl, l = match scope with
    | Locality.Global import_behavior -> process_assumptions_udecls l
    | Locality.Discharge -> None, process_assumptions_no_udecls l in
  let sigma, udecl = interp_univ_decl_opt env udecl in
  let l =
    if poly then
      (* Separate declarations so that A B : Type puts A and B in different levels. *)
      List.fold_right (fun (is_coe,(idl,c)) acc ->
        List.fold_right (fun id acc ->
          (is_coe, ([id], c)) :: acc) idl acc)
        l []
    else l
  in
  (* We interpret all declarations in the same evar_map, i.e. as a telescope. *)
  let (sigma,_,_),l = List.fold_left_map (fun (sigma,env,ienv) (is_coe,(idl,c)) ->
    let sigma,t,imps = interp_assumption ~program_mode env sigma ienv [] c in
    let r = Retyping.relevance_of_type env sigma t in
    let env =
      EConstr.push_named_context (List.map (fun {CAst.v=id} -> LocalAssum (make_annot id r,t)) idl) env in
    let ienv = List.fold_right (fun {CAst.v=id} ienv ->
      let impls = compute_internalization_data env sigma id Variable t imps in
      Id.Map.add id impls ienv) idl ienv in
      ((sigma,env,ienv),((is_coe,idl),t,imps)))
    (sigma,env,empty_internalization_env) l
  in
  let sigma = solve_remaining_evars all_and_fail_flags env sigma in
  (* The universe constraints come from the whole telescope. *)
  let sigma = Evd.minimize_universes sigma in
  let nf_evar c = EConstr.to_constr sigma c in
  let uvars, l = List.fold_left_map (fun uvars (coe,t,imps) ->
      let t = nf_evar t in
      let uvars = Univ.LSet.union uvars (Vars.universes_of_constr t) in
      uvars, (coe,t,imps))
      Univ.LSet.empty l
  in
  (* XXX: Using `Declare.prepare_parameter` here directly is not
     possible as we indeed declare several parameters; however,
     restrict_universe_context should be called in a centralized place
     IMO, thus I think we should adapt `prepare_parameter` to handle
     this case too. *)
  let sigma = Evd.restrict_universe_context sigma uvars in
  let univs = Evd.check_univ_decl ~poly sigma udecl in
  let ubinders = Evd.universe_binders sigma in
  declare_assumptions ~poly ~scope ~kind (univs,ubinders) nl l

let context ~poly l =
  let env = Global.env() in
  let sigma = Evd.from_env env in
  let sigma, (_, ((_env, ctx), impls)) = interp_context_evars ~program_mode:false env sigma l in
  (* Note, we must use the normalized evar from now on! *)
  let ce t = Pretyping.check_evars env sigma t in
  let () = List.iter (fun decl -> Context.Rel.Declaration.iter_constr ce decl) ctx in
  let sigma, ctx = Evarutil.finalize ~abort_on_undefined_evars:false
      sigma (fun nf -> List.map (RelDecl.map_constr_het nf) ctx) in
  (* reorder, evar-normalize and add implicit status *)
  let ctx = List.rev_map (fun d ->
      let {binder_name=name}, b, t = RelDecl.to_tuple d in
      let name = match name with
        | Anonymous -> user_err Pp.(str "Anonymous variables not allowed in contexts.")
        | Name id -> id
      in
      let impl = let open Glob_term in
        let search x = match x.CAst.v with
        | Some (Name id',max) when Id.equal name id' ->
          Some (if max then MaxImplicit else NonMaxImplicit)
        | _ -> None
        in
        try CList.find_map search impls with Not_found -> Explicit
      in
      let kind = Decls.(if b = None then IsAssumption Context else IsDefinition LetContext) in
      let data = (impl,kind,false,[]) in
      (name,b,t,data))
      ctx
  in
  let univs = (Evd.univ_entry ~poly sigma, Evd.universe_binders sigma) in
  let open Locality in
  let scope =
    if Global.sections_are_opened () then Discharge
    else Global (if Lib.is_modtype () then ImportDefaultBehavior else ImportNeedQualified)
  in
  declare_context ~poly ~scope univs Declaremods.NoInline ctx
